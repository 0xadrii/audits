# [0xadrii] Bug disclosure - Not considering fees when computing Operator Delegator's ETH balance breaks ezETH's exchange rate and creates accounting issues

## Initial context
The following bug report describes how native ETH deposits and the current logic to handle Execution Layer Rewards generated in the EigenPods handled by Renzo have been breaking ezETH's peg.

### Tracking each OperatorDelegator's native ETH balance
Initially, we must understand how Renzo tracks each OperatorDelegator's native ETH balance. The total ETH balance for each OperatorDelegator is determined by the `getStakedETHBalance` function:
```solidity
function getStakedETHBalance() external view returns (uint256) {
        ...
        return
            stakedButNotVerifiedEth + 
            address(eigenPod).balance +  
            pendingUnstakedDelayedWithdrawalAmount; 
    }
```
The ETH balance is composed by three different values:
- `stakedButNotVerifiedEth`: This variable tracks the amount of staked ETH in the OperatorDelegator. It is correct to return it in the function.
- `address(eigenPod).balance`: This is the native ETH balance currently held by the EigenPod, and is directly related with `pendingUnstakedDelayedWithdrawalAmount`. It is returned in this function so that Renzo can have a preview of how many rewards have been generated by the EigenPod from Execution Layer Rewards.
- `pendingUnstakedDelayedWithdrawalAmount`: When a delayed withdrawal is triggered via the `startDelayedWithdrawUnstakedETH` function to fetch the native ETH rewards held in the EigenPod, such ETH rewards will be transferred from the EigenPod to EigenLayer's `DelayedWithdrawalRouter` contract instead of being directly transferred to Renzo. This will make `address(eigenPod).balance` instantly decrease in the previous field, so `startDelayedWithdrawUnstakedETH` will track the current amount being held in the delayed withdrawal router.


### Determining the amount of ezETH to be minted
When ezETH is minted in the protocol, the following computation takes place:

```solidity
// RestakeManager.sol

function depositETH(uint256 _referralId) public payable nonReentrant notPaused {
        // Get the total TVL
        (, , uint256 totalTVL) = calculateTVLs();
  
        ...
        // Calculate how much ezETH to mint
        uint256 ezETHToMint = renzoOracle.calculateMintAmount(
            totalTVL,
            msg.value, 
            ezETH.totalSupply() 
        );

        // Mint the ezETH
        ezETH.mint(msg.sender, ezETHToMint);

        ...
    }
```

As we can see, the `ezETHToMint` is the amount of ezETH that will be minted to the user given by the function `calculateMintAmount`. The computation performed inside the `calculateMintAmount` is similar to the one performed in ERC4626 vaults, where the ezETH amount to be minted will come determined by the inflation that the deposit causes. There are three important parameters to determine the ezETH amount to be minted:
- `totalTVL`: The total TVL held in the protocol, this is given by the `calculateTVLs` function, which we will discuss later
- `msg.value`/assets to deposit
- ezETH's `totalSupply`

In order to compute the total TVL, each Operator Delegator is queried their current token balance + ETH balance (where the ETH balance is extracted by calling each OperatorDelegator's `getStakedETHBalance` function, hence why `getStakedETHBalance` is extremely important).

### Fees applied when receiving Execution Layer Rewards
Renzo charges fees (currently set at 10%) for all the Execution Layer Rewards generated into OperatorDelegator's EigenPod. When a delayed withdrawal is executed and funds are finally transferred from the EigenPod to Renzo, the following steps will be performed:
1. Execution Layer Rewards will be transferred from the EigenPod to the Operator Delegator. The OperatorDelegator will receive the rewards via its `receive` function, and redirect them to the DepositQueue contract.
2. When the DepositQueue contract receives the Execution Layer Rewards via its `receive` function, a fee will be applied and transferred to Renzo's treasury:
```solidity
receive() external payable nonReentrant {
        uint256 feeAmount = 0;
        // Take protocol cut of rewards if enabled
        if (feeAddress != address(0x0) && feeBasisPoints > 0) {
            feeAmount = (msg.value * feeBasisPoints) / 10000;
            (bool success, ) = feeAddress.call{ value: feeAmount }("");
            if (!success) revert TransferFailed();

            emit ProtocolFeesPaid(IERC20(address(0x0)), feeAmount, feeAddress);
        }

        ...
    }
```

## The problem

As we have seen, the total TVL is used in order to determine the new amount of ezETH to be minted (and hence, the ezETH exchange rate against ETH). The problem is that when the native ETH balance from each operator is queried in order to determine the protocol's total TVL (which not only considers the staked ETH but also the generated Execution Layer Rewards generated by each EigenPod), Renzo's fees applied later when the Execution Layer Rewards are actually transferred to the DepositQueue are not accounted for. This will make all calculations regarding Renzo's total TVL be wrong, thus breaking ezETH's exchange rate. Essentially, the fees generated are considered as Renzo's TVL, when in reality they don't belong to the protocol and don't correspond to users that have minted ezETH.

The attached proof of concept further details how this impacts the protocol, and addresses the severity of the issue.

### Proof of Concept
Let's imagine the following scenario to understand the problem (LST's are not considered in order to simplify), where only one operator delegator exists:
1. Initially, the protocol is in the current state:
    - `stakedButNotVerifiedEth` is 32 ETH
    - `address(eigenPod).balance` is 10 ETH (so 10 ETH have been generated as Execution Layer Rewards)
    - `pendingUnstakedDelayedWithdrawalAmount` is 0
    - the Deposit Queue's balance is 0
    - The total TVL in the protocol is 42 ETH (the value returned by the Operator's `getStakedETH` function plus the deposit queue's balance, which is`stakedButNotVerifiedEth` + `address(eigenPod).balance` + `pendingUnstakedDelayedWithdrawalAmount` + the deposit queue's balance)
2. Renzo's team decides to process the EigenPod's rewards by calling the OperatorDelegator's `startDelayedWithdrawUnstakedETH` function. This will make the state change and become the following:
    - `stakedButNotVerifiedEth` remains the same, 32 ETH
    - `address(eigenPod).balance` is now 0 ETH (all the ETH has been transferred to EigenLayer's Delayed Withdrawal Router)
    - `pendingUnstakedDelayedWithdrawalAmount` has increased to 10 ETH so that balance is properly tracked
    - the Deposit Queue's balance is still 0
    - The total TVL in the protocol is still 42 ETH (the value returned by the Operator's `getStakedETH` function, which is`stakedButNotVerifiedEth` + `address(eigenPod).balance` + `pendingUnstakedDelayedWithdrawalAmount` + the deposit queue's balance)

3. When the delayed withdrawal time passes, rewards can be actually transferred to the Renzo protocol. EigenLayer's Delayed Withdrawal Router's `claimDelayedWithdrawals` function is called, and the 10 ETH of Execution Layer Rewards are transferred to the queue. However, as mentioned before, a 10% of fees applies, so when the 10 ETH arrive to the deposit queue, 1 ETH goes directly to Renzo's treasury, and the following values are held in the protocol:
    - `stakedButNotVerifiedEth` remains the same, 32 ETH
    - `address(eigenPod).balance` is still 0 ETH 
    - `pendingUnstakedDelayedWithdrawalAmount` has decreased to 0 ETH, given that the pending unstaked amount has been withdrawn and transferred to the DepositQueue
    - the Deposit Queue's balance is now 9 ETH (**NOT 10 ETH, because a 10% fee was applied**)
    - **The total TVL in the protocol has now decreased from 42 ETH to 41 ETH** due to the fee applied (the value returned by the Operator's `getStakedETH` function, which is`stakedButNotVerifiedEth` + `address(eigenPod).balance` + `pendingUnstakedDelayedWithdrawalAmount`)


As we can see, there's a differrence in the total TVL calculations performed, which directly affect the amount of ezETH to be minted, and inevitably, its exchange rate.It is clear that ezETH's exchange rate fluctuates depending if the delayed withdrawal rewards have been transferred to Renzo or not. 

Following the example, and considering an existing ezETH supply of 32 ETH (the 32 ETH staked were initially minted at a 1:1 rate) and **PRIOR** to step 3 taking place, ezETH's exchange rate will be 0,761904761904761901 (computation given by Renzo's Oracle).
On the other hand, also considering an existing ezETH supply of 32 ETH, but performing the calculation **AFTER** step 3 taking place, ezETH's exchange rate will be 0,780487804878048762. This is the actual calculation that should always take place, because in this second calculation

As we can see, the difference in the exchange rate is a 2%, which is an **extremely high difference** between.


It is also important to acknowledge the fact that **this issue compounds in an exponential manner**. Every time a scenario typical to the one described before (where the ezETH amount to be minted/reedemed is extracted by utilizing the protocol's total TVL without considering that fees shouldn't be actually accounted as protocol TVL), the gap between the wrongly computed ezETH's exchange rate and the exchange rate that should actually be computed increases, affecting all the users that interact with the protocol, and leading to losses.

## Impact
Critical. Renzo protocol is built around the concept of ezETH, which is a reward bearing token similar to cTokens or AAVE's aTokens. Breaking the exchange will have fatal consequences, given that users will be minted/burnt a wrong amount of ezETH whenever they interact with the protocol. The impact also increases if we consider the fact that the L2's where Renzo is deployed receive the ezETH's exchange rate price via the `xRenzoBridge`, which is a contract that also computes ezETH's exchange rate in the wrong way (given that it utilizes the same calculations and data explained in the bug description). This issue can mainly lead to funds remaining stuck forever in the protocol, given that incorrectly calculating the exchange rate will make users get more/less tokens than they should depending on the protocol state.

## Recommendation
It is recommended to account for the fees when the native ETH balance is computed in the operator delegator. This can be done by updating the `calculateTVLs` function inside the `RestakeManager` contract in the following manner:

```diff
// RestakeManager.sol
function calculateTVLs() public view returns (uint256[][] memory, uint256[] memory, uint256) {
...
for (uint256 i = 0; i < odLength; ) {
            ...
            // Iterate through the tokens and get the value of each
            uint256 tokenLength = collateralTokens.length;
            for (uint256 j = 0; j < tokenLength; ) {
                // Get the value of this token
                uint256 operatorBalance = operatorDelegators[i].getTokenBalanceFromStrategy(
                    collateralTokens[j]
                );

                // Set the value in the array for this OD
                operatorValues[j] = renzoOracle.lookupTokenValue(
                    collateralTokens[j], 
                    operatorBalance
                );
 
                // Add it to the total TVL for this OD
                operatorTVL += operatorValues[j];

                unchecked {
                    ++j;
                }
            }
 
            // Get the value of native ETH staked for the OD
            uint256 operatorEthBalance = operatorDelegators[i].getStakedETHBalance();
               
       
+            if(depositQueue.feeAddress() != address(0) && depositQueue.feeBasisPoints() > 0) {}
+                uint256 feeAmount = (operatorEthBalance * depositQueue.feeBasisPoints()) / 10000;
+                operatorEthBalance -= feeAmount;
+            }
            
            // Save it to the array for the OD
            operatorValues[operatorValues.length - 1] = operatorEthBalance;
 
            // Add it to the total TVL for this OD
            operatorTVL += operatorEthBalance;

            // Add it to the total TVL for the protocol
            totalTVL += operatorTVL;

            // Save the TVL for this OD
            operatorDelegatorTVLs[i] = operatorTVL;

            unchecked {
                ++i;
            }
        }
```

## Additional note

It is really hard to determine how off the exchange rate of ezETH is with the exchange rate that should have been since Renzo's deployment. I'd be happy to join the Renzo team in a war room to discuss the possible next steps and see the best way to approach the issue

## Resolution

Duplicate.